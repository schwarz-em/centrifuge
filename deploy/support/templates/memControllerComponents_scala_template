package memControl

import chisel3._
import chisel3.util._
import freechips.rocketchip.tile._
import org.chipsalliance.cde.config._
import freechips.rocketchip.diplomacy._
import freechips.rocketchip.rocket._
import freechips.rocketchip.tilelink._
//import freechips.rocketchip.util.InOrderArbiter
import freechips.rocketchip.util._
import freechips.rocketchip.system._

import vivadoHLS._
import controlUtils._

class RequestParserIO(dataWidth: Int, addrWidth: Int) extends Bundle{
  val reqIn = Flipped(new ApBusReq(dataWidth, addrWidth))
  val reqOut = new ApBusReq(dataWidth, addrWidth)
  val offsetAddr = Input(UInt(addrWidth.W))
  val loadOffset = Input(Bool())
}
class RequestParser(dataWidth: Int, addrWidth: Int) extends Module{
  val io = IO(new RequestParserIO(dataWidth, addrWidth))
  
  val offsetReg = RegInit(0.U(addrWidth.W))

  val multAmt = (dataWidth/8).U

  when(io.loadOffset){
    offsetReg := io.offsetAddr
  }

  io.reqOut.din     := io.reqIn.din
  io.reqOut.dataout := io.reqIn.dataout
  io.reqOut.size    := io.reqIn.size

  io.reqOut.address := (io.reqIn.address*multAmt) + offsetReg 
}

class TimestampedRequestIO(dataWidth:Int, addrWidth:Int, counterSize: Int) extends Bundle{
  val req = new ApBusReq(dataWidth, addrWidth)
  val timestamp = Input(UInt(log2Up(counterSize).W))
}

class ApBusReqType (dataWidth:Int, addrWidth:Int) extends Bundle{
  //Req specific lines
  //Specifies a write request
  val din     = Bool() //req_din in verilog

  //Lines used for req
  val address     = UInt(addrWidth.W)
  val dataout     = UInt(dataWidth.W)
  val size        = UInt(addrWidth.W)
}

class TimestampedRequestIOType(dataWidth:Int, addrWidth:Int, counterSize: Int) extends Bundle{
  val req = new ApBusReqType(dataWidth, addrWidth)
  val timestamp = UInt(log2Up(counterSize).W)
}


class RequestIngestIO(dataWidth: Seq[Int], addrWidth: Seq[Int], counterSize: Int, inputBufferLen: Int) extends Bundle{
  //val reqsIn  = Vec.tabulate(dataWidth.length)((i) => Wire(new ApBusReq(dataWidth(i), addrWidth(i)).flip))
  val reqsIn = Flipped(HeterogeneousBag.apply(dataWidth.zip(addrWidth).map {
    case (dw, aw) => new ApBusReq(dw, aw)
  }))
 
  val reqsFullN = Vec(dataWidth.length, Output(Bool()))
  //val reqsWrite = Vec(dataWidth.length, Bool(INPUT)).flip
  val reqsWrite = Vec(dataWidth.length, Input(Bool()))
  //val offsetAddrs = Vec.tabulate(dataWidth.length)((i) => UInt(INPUT, width=addrWidth(i)))
  //val offsetAddrs = HeterogeneousBag.apply(addrWidth.map(aw => UInt(INPUT, width = aw)))
  val offsetAddrs = HeterogeneousBag.apply(addrWidth.map(aw => Input(UInt(aw.W))))
  //val loadOffsets = Vec(dataWidth.length, Bool(INPUT)).flip
  val loadOffsets = Vec(dataWidth.length, Input(Bool()))

  val newRequests = Output(UInt((log2Up(dataWidth.length)+1).W)) //The number of new requests recieved in this cycle (used to track number of outstanding requests)

  //The widths are the maximums of all of the input widths
  val reqOut = Decoupled(new ApBusReq(if (dataWidth.length > 0) dataWidth.max else 0, if (addrWidth.length > 0) addrWidth.max else 0))
  val selectedBus = Output(UInt(log2Up(dataWidth.length).W))
}

class RequestIngest(dataWidth: Seq[Int], addrWidth: Seq[Int], inputBufferLen: Int) extends Module{
  val busCount = dataWidth.length
  //We only need enough counter values to account for the worst case scenario when memory is stalled and each buffer is filled one at a time
  //Adding an extra 1 is probably overly conservative as the extra one may be reassigned but is not at the front of the queue.  If it was, then a queue is not 
  //Taking the base 2 log and rasing 2 to that power ensures that the overflow semantics are what is expected.  This is important for the priority difference
  val counterSize = BigInt(2).pow(log2Up(inputBufferLen*busCount)).toInt
  
  val io = IO(new RequestIngestIO(dataWidth, addrWidth, counterSize, inputBufferLen))

  val counter = Counter(counterSize)

  val prevTimestamp = RegInit(0.U(log2Up(counterSize).W))

  val parsers = Seq.tabulate(busCount)((i) => Module(new RequestParser(dataWidth(i), addrWidth(i))).io)

  //val queues = Vec.tabulate(busCount)((i) => Module(new Queue(new TimestampedRequestIOType(dataWidth(i), addrWidth(i), log2Up(counterSize)), inputBufferLen)))
  val queues = Seq.tabulate(busCount)((i) => Module(new Queue(new TimestampedRequestIOType(dataWidth(i), addrWidth(i), log2Up(counterSize)), inputBufferLen)).io)
  /*val queues = HeterogeneousBag.apply(dataWidth.zip(addrWidth).map{ 
      case (dw, aw) => Module(new Queue(new TimestampedRequestIOType(dw, aw, log2Up(counterSize)), inputBufferLen))
  })*/ 
  //Vec.tabulate(busCount)((i) => Module(new Queue(new TimestampedRequestIO(dataWidth(i), addrWidth(i), log2Up(counterSize)), inputBufferLen)).io)

  val arbiter = Module(new PriorityArbiter(new ApBusReq(if (dataWidth.length > 0) dataWidth.max else 0, if (addrWidth.length > 0) addrWidth.max else 0), busCount, log2Up(counterSize)))

  val incrCounter = WireDefault(false.B)  
  if (dataWidth.length > 0) {    
    incrCounter := io.reqsWrite.reduce(_||_)
  }
  //+1 is because we need to be able to represent 0 and BusCount not BusCount-1
  val requestsUInt = io.reqsWrite.map((x) => Mux(x, 1.U(busCount.W), 0.U((busCount+1).W)))

  if (dataWidth.length > 0) {    
    io.newRequests := requestsUInt.reduce(_+_)
  }

  //Increment counter when any request comes in
  when(incrCounter){
    counter.inc()
  }

  for(i <- 0 until busCount){
    parsers(i).offsetAddr        := io.offsetAddrs(i)
    parsers(i).loadOffset        := io.loadOffsets(i)
    parsers(i).reqIn             := io.reqsIn(i)
    //parsers(i).reqIn           <> io.reqsIn(i)
    queues(i).enq.bits.req       := parsers(i).reqOut
    queues(i).enq.bits.timestamp := counter.value //put in the timestamp! 
    io.reqsFullN(i)              := queues(i).enq.ready
    queues(i).enq.valid          := io.reqsWrite(i)
    queues(i).deq.ready          := arbiter.io.in(i).ready
    arbiter.io.in(i).valid       := queues(i).deq.valid
    arbiter.io.in(i).bits        := queues(i).deq.bits.req
    //Priority is oldest first.  It is defined as the difference from the last serviced timestamp
    arbiter.io.priority(i)       := queues(i).deq.bits.timestamp - prevTimestamp //This works even with overlfow so long as counterSize is a power of 2
  }

  when(arbiter.io.out.valid && io.reqOut.ready){
    prevTimestamp := prevTimestamp + arbiter.io.priorityOut
  }

  //io.reqOut := arbiter.io.out
  io.reqOut.valid := arbiter.io.out.valid
  arbiter.io.out.ready := io.reqOut.ready
  io.reqOut.bits := arbiter.io.out.bits
  io.selectedBus := arbiter.io.chosen 
}

class RequestIssuerIO(dataWidth: Int, addrWidth:Int, maxReqWidth:Int, numBus:Int, roccAddrWidth:Int, roccDataWidth:Int, roccTagWidth:Int, roccCmdWidth:Int, roccTypWidth:Int) extends Bundle{
  //Incoming request from arbiter
  //val reqIn = Decoupled(new ApBusReq(dataWidth, addrWidth)).flip
  val reqIn = Flipped(Decoupled(new ApBusReq(dataWidth, addrWidth)))
  //The bus that the request came from
  val reqBus = Input(UInt(log2Up(numBus).W))

  //Lines for table address check and for updating the table
  val accessWidth = Output(UInt(maxReqWidth.W))
  val accessRead = Output(Bool())
  val conflict = Input(Bool())
  //val tagQueueIO = Decoupled(UInt(OUTPUT, width=roccTagWidth)).flip
  val tagQueueIO = Flipped(Decoupled(Output(UInt(roccTagWidth.W))))
  val busNum = Output(UInt(log2Up(numBus).W))
  
  //RoCC Lines
  val roCCReqAddr  = Output(UInt(roccAddrWidth.W)) // coreMaxAddrBits)
  val roCCReqTag   = Output(UInt(roccTagWidth.W)) //coreDCacheReqTagBits)
  val roCCReqCmd   = Output(UInt(roccCmdWidth.W)) //M_SZ)
  val roCCReqTyp   = Output(UInt(roccTypWidth.W)) //
  val roCCReqData  = Output(UInt(roccDataWidth.W)) //coreDataBits)
  val roCCReqValid = Output(Bool())
  val roCCReqRdy   = Input(Bool())

  val reqWidth     = Output(UInt(maxReqWidth.W)) //Pass to table to specify width of request

  val reqSent      = Output(Bool())
}

//maxReqBytes = 8 (64 bit) in our case
class RequestIssuer(dataWidth: Int, addrWidth:Int, maxReqBytes:Int, roccAddrWidth:Int, roccDataWidth:Int, roccTagWidth:Int, roccCmdWidth:Int, roccTypWidth:Int, busDataWidths:Seq[Int]) extends Module{
  val maxReqWidth = log2Up(maxReqBytes)
  val numBus = busDataWidths.length
  val io = IO(new RequestIssuerIO(dataWidth, addrWidth, maxReqWidth, numBus, roccAddrWidth, roccDataWidth, roccTagWidth, roccCmdWidth, roccTypWidth))

if (busDataWidths.length > 0) {
  val busByteWidth = VecInit(busDataWidths.map((x) => x.U / 8.U))

  val currentByteWidth = busByteWidth(io.reqBus)


  io.busNum       := io.reqBus
  io.roCCReqAddr  := io.reqIn.bits.address
  io.roCCReqData  := io.reqIn.bits.dataout
  io.roCCReqTag   := io.tagQueueIO.bits
  io.roCCReqCmd   := Mux(io.reqIn.bits.din, M_XWR, M_XRD) //Set the transaction type (Write / Read)
  io.roCCReqTyp   := Mux(currentByteWidth===8.U, log2Ceil(8).U, Mux(currentByteWidth===4.U, log2Ceil(4).U, Mux(currentByteWidth===2.U, log2Ceil(2).U, log2Ceil(1).U))) //Set transaction width
  io.reqWidth     := currentByteWidth

  io.accessWidth  := currentByteWidth
  io.accessRead   := !io.reqIn.bits.din

  io.roCCReqValid := io.reqIn.valid && !io.conflict && io.tagQueueIO.valid

  val memTransactSent = io.reqIn.valid && io.roCCReqRdy && !io.conflict && io.tagQueueIO.valid

  io.reqIn.ready  := memTransactSent
  io.tagQueueIO.ready := memTransactSent //We used a tag when we issued a request
  io.reqSent := memTransactSent
}
}

class RoutingTableIO(tagWidth:Int, numBus:Int, addrWidth: Int, maxReqWidth: Int) extends Bundle{
  val reqValid = Input(Bool())
  val reqTag   = Input(UInt(tagWidth.W))
  val reqWrite = Input(Bool()) //If the transaction is a write
  val reqAddr  = Input(UInt(addrWidth.W))
  val reqBus   = Input(UInt(log2Up(numBus).W))
  val reqWidth = Input(UInt(maxReqWidth.W))

  val checkAddr = Input(UInt(addrWidth.W))
  val checkWidth = Input(UInt(maxReqWidth.W))
  val checkRead = Input(Bool())
  val conflict = Output(Bool())

  val respTag = Input(UInt(tagWidth.W))
  val respValid = Input(Bool()) // Note: fixed typo from `respVaid` to `respValid`
  val respBus = Output(UInt(log2Up(numBus).W))
}

//maxReqBytes = 8 (64 bit) in our case
class RoutingTable(tagWidth:Int, numTags:Int, numBus:Int, addrWidth: Int, maxReqBytes: Int) extends Module{
  val maxReqWidth = log2Up(maxReqBytes)
  //val numTags = BigInt(2).pow(tagWidth).toInt

  val io = IO(new RoutingTableIO(tagWidth, numBus, addrWidth, maxReqWidth))

  if (addrWidth > 0) {

    val v = RegInit(VecInit(Seq.fill(numTags)(false.B))) //valid (outstanding memory request)
    val write = RegInit(VecInit(Seq.fill(numTags)(false.B))) // outstanding request is a write
    val addr = RegInit(VecInit(Seq.fill(numTags)(0.U(addrWidth.W))))
    val width = RegInit(VecInit(Seq.fill(numTags)(0.U(maxReqWidth.W))))
    val bus = RegInit(VecInit(Seq.fill(numTags)(0.U(log2Up(numBus).W))))

    //write Req into table 
    when(io.reqValid){
      v(io.reqTag) := true.B       //Set table entry as valid
      write(io.reqTag) := io.reqWrite  //Set write flag
      addr(io.reqTag)  := io.reqAddr   //Set addr
      width(io.reqTag) := io.reqWidth  //Set transaction width (in bytes)
      bus(io.reqTag)   := io.reqBus    //Set the requesting bus
    }

    //clear returned transaction.  The tag queue prevents accedently claring a tag that has not yet returned
    when(io.respValid){
      v(io.respTag) := false.B //This entry is no longer valid
    }

    //Return the bus that requsted the returning transaction
    io.respBus := bus(io.respTag)

    //Reads can execute if there is no outstanding write to the address (v==false || write==false)
    //    Reads stall when v==true and write==true
      
    //Writes can only occure if there are no outstanding ops (v==false)
    //    Writes stall when v==true

    val addrsConflicting = VecInit(Seq.tabulate(numTags)((i) => !((io.checkAddr + io.checkWidth <= addr(i)) || (addr(i) + width(i) <= io.checkAddr))))

    //There is a conflict if: the address is conflicting, the entry is valid, and if(reading, there is an outstanding write)
    val conflicting = VecInit(Seq.tabulate(numTags)((i) => addrsConflicting(i) && v(i) && Mux(io.checkRead, write(i), true.B)))

    io.conflict := conflicting.reduce(_||_)
  }
}

class MemControllerIO(dataWidth:Seq[Int], addrWidth:Seq[Int], roccAddrWidth:Int, roccDataWidth:Int, roccTagWidth:Int, roccCmdWidth:Int, roccTypWidth:Int) extends Bundle{
  //----ap_bus requests----
  val reqsIn = Flipped(HeterogeneousBag.apply(dataWidth.zip(addrWidth).map {
    case (dw, aw) => new ApBusReq(dw, aw)
  }))
  //Decoupled signals for requests
  val reqsFullN = Vec(dataWidth.length, Output(Bool()))
  //val reqsWrite = Vec(dataWidth.length, Bool(INPUT)).flip
  val reqsWrite = Vec(dataWidth.length, Input(Bool()))
//Offset address lines
  //val offsetAddrs = Vec.tabulate(dataWidth.length)((i) => UInt(INPUT, width=addrWidth(i)))
  val offsetAddrs = HeterogeneousBag.apply(addrWidth.map(aw => Input(UInt(aw.W))))
  //val loadOffsets = Vec(dataWidth.length, Bool(INPUT)).flip
  val loadOffsets = Vec(dataWidth.length, Input(Bool()))

  //----status line----
  val memBusy = Output(Bool())

  //----ap_bus response----
  val rspOut = Flipped(HeterogeneousBag.apply(dataWidth.map(dw => new ApBusRsp(dw))))
  val rsp_empty_n = Vec(dataWidth.length, Output(Bool())) // This is the same as valid
  val rsp_read = Vec(dataWidth.length, Input(Bool())) // This is the same as ready

  //----RoCC Mem Req----
  val roCCReqAddr  = Output(UInt(roccAddrWidth.W))
  val roCCReqTag   = Output(UInt(roccTagWidth.W))
  val roCCReqCmd   = Output(UInt(roccCmdWidth.W))
  val roCCReqTyp   = Output(UInt(roccTypWidth.W))
  val roCCReqData  = Output(UInt(roccDataWidth.W))
  val roCCReqValid = Output(Bool())
  val roCCReqRdy   = Input(Bool())

  // RoCC Response signals
  val roCCRspTag   = Input(UInt(roccTagWidth.W))
  val roCCRspCmd   = Input(UInt(roccCmdWidth.W))
  val roCCRspData  = Input(UInt(roccDataWidth.W))
  val roCCRspValid = Input(Bool())
}

class MemController(dataWidth:Seq[Int], addrWidth:Seq[Int], reqBufferLen:Int, rspBufferLen:Int, maxReqBytes:Int, roccAddrWidth:Int, roccDataWidth:Int, roccTagWidth:Int, roccCmdWidth:Int, roccTypWidth:Int, numTags:Int, tagOffset:Int ) extends Module{
  val io = IO(new MemControllerIO(dataWidth, addrWidth, roccAddrWidth, roccDataWidth, roccTagWidth, roccCmdWidth, roccTypWidth))

  val numBus = dataWidth.length
if (numBus > 0){
  val reqIngest = Module(new RequestIngest(dataWidth, addrWidth, reqBufferLen))
  val reqIssuer = Module(new RequestIssuer(if (dataWidth.length > 0) dataWidth.max else 0, if (addrWidth.length > 0) addrWidth.max else 0, maxReqBytes, roccAddrWidth, roccDataWidth, roccTagWidth, roccCmdWidth, roccTypWidth, dataWidth))
  val scoreboard = Module(new RoutingTable(roccTagWidth, numTags, numBus, if (addrWidth.length > 0) addrWidth.max else 0, maxReqBytes))
  
  //Tags may have an offset if this is not the only accelerator in the system
  val tags = (tagOffset until (tagOffset+numTags))
  val tagUInts = tags.map((x) => x.U(roccTagWidth.W))
  val tagQueue = Module(new RegisterQueue(gen=UInt(roccTagWidth.W),  entries=numTags,  initVals=tagUInts, flow=true))
  val rspQueues = Seq.tabulate(numBus)((i) => Module(new Queue(UInt(dataWidth(i).W), rspBufferLen)).io)
  val validDemux = Module(new ValidDemux(numBus))

  val currentRequestNum = RegInit(0.U((reqBufferLen*numBus+1+numTags).W))

  //Logic for number of outstanding requests
  currentRequestNum := currentRequestNum + reqIngest.io.newRequests - Mux(io.roCCRspValid, 1.U, 0.U)
  io.memBusy := currentRequestNum =/= 0.U

  //==== Ingest Logic ====
  //Hook up ap_bus request lines to ingest logic
  //reqIngest.io.reqsIn      <> io.reqsIn
  reqIngest.io.reqsIn  := io.reqsIn
  io.reqsFullN              := reqIngest.io.reqsFullN
  reqIngest.io.reqsWrite    := io.reqsWrite
  reqIngest.io.offsetAddrs  := io.offsetAddrs
  //io.offsetAddrs  := reqIngest.io.offsetAddrs
  reqIngest.io.loadOffsets  := io.loadOffsets

  //val newRequests

  //val reqOut  
  //val selectedBus 

  //====Req Issuer ====
  //Incoming request from arbiter
  //reqIssuer.io.reqIn <> reqIngest.io.reqOut
  reqIssuer.io.reqIn.bits   := reqIngest.io.reqOut.bits
  reqIssuer.io.reqIn.valid  := reqIngest.io.reqOut.valid
  reqIngest.io.reqOut.ready := reqIssuer.io.reqIn.ready
  //The bus that the request came from
  reqIssuer.io.reqBus := reqIngest.io.selectedBus

  //Lines for table address check and for updating the table
  //val accessWidth 
  //val containsAddr 
  //reqIssuer.io.tagQueue <> tagQueue.io.deq
  reqIssuer.io.tagQueueIO.bits  := tagQueue.io.deq.bits
  reqIssuer.io.tagQueueIO.valid := tagQueue.io.deq.valid
  tagQueue.io.deq.ready       := reqIssuer.io.tagQueueIO.ready
  //val busNum  
  //val reqWidth   //Pass to table to specify width of request 
  
  //RoCC Lines
  io.roCCReqAddr          := reqIssuer.io.roCCReqAddr  
  io.roCCReqTag           := reqIssuer.io.roCCReqTag   
  io.roCCReqCmd           := reqIssuer.io.roCCReqCmd
  io.roCCReqTyp           := reqIssuer.io.roCCReqTyp
  io.roCCReqValid         := reqIssuer.io.roCCReqValid
  reqIssuer.io.roCCReqRdy := io.roCCReqRdy
  io.roCCReqData          := reqIssuer.io.roCCReqData

  //====Scoreboard====
  scoreboard.io.reqValid :=  reqIssuer.io.reqSent //Do not commit into the table unles there is a fire
  scoreboard.io.reqTag   :=  reqIssuer.io.roCCReqTag
  scoreboard.io.reqWrite := (reqIssuer.io.roCCReqCmd === M_XWR)  //If the transaction is a write
  scoreboard.io.reqAddr  :=  reqIssuer.io.roCCReqAddr 
  scoreboard.io.reqBus   :=  reqIssuer.io.busNum
  scoreboard.io.reqWidth :=  reqIssuer.io.reqWidth

  scoreboard.io.checkAddr   := reqIssuer.io.roCCReqAddr 
  scoreboard.io.checkWidth  := reqIssuer.io.accessWidth
  scoreboard.io.checkRead   := reqIssuer.io.accessRead
  reqIssuer.io.conflict     := scoreboard.io.conflict

  scoreboard.io.respTag  := io.roCCRspTag
  scoreboard.io.respValid := io.roCCRspValid
  //val scoreboard.io.respBus 

  //====TagQueue====
  tagQueue.io.enq.bits  := io.roCCRspTag
  tagQueue.io.enq.valid := io.roCCRspValid

  //====Demux=====
  validDemux.io.validIn     := io.roCCRspValid && io.roCCRspCmd===M_XRD //Only return to the bus if this is a response to a read request
  validDemux.io.validSelect := scoreboard.io.respBus
  //val validOut = Vec.fill(fanout)(Bool(OUTPUT))

  //====RespQueues====
  for(i <- 0 until numBus){
    rspQueues(i).enq.bits  := io.roCCRspData((dataWidth(i)-1),0) //Pass the data to all output queues (slicing to approprite width), only give one the valid signal
    rspQueues(i).enq.valid := validDemux.io.validOut(i)
    io.rspOut(i).datain    := rspQueues(i).deq.bits
    io.rsp_empty_n(i)      := rspQueues(i).deq.valid
    rspQueues(i).deq.ready := io.rsp_read(i)
  }
}
}
